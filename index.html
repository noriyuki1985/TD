<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>タワーディフェンス – 敵移動＆ライフ管理</title>
  <!-- GitHub Pages で /TD/ 配下とみなす -->
  <base href="/TD/" />
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body { background:#222; color:#fff; font-family:sans-serif; }
    #game-container { position:relative; width:800px; height:800px; margin:20px auto; border:2px solid #fff; }
    #game-canvas { display:block; }
    #hud { position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.5); padding:5px 10px; border-radius:4px; font-size:16px; }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas" width="1600" height="1600"></canvas>
    <div id="hud"></div>
  </div>

  <script type="module">
  //──────────────────────────────────────────────────────
  // 1) 設定
  const CONFIG = {
    TILE_SIZE:   32,
    MAP_ROWS:    50,
    MAP_COLS:    50,
    ASSETS_PATH: 'assets/images',
    ENEMY_DEFINITIONS: [
      { id:'slime',       hp:50,  speed:1.2, reward: 5, spriteKey:'enemy_slime' },
      { id:'orc_soldier', hp:200, speed:1.0, reward:20, spriteKey:'enemy_orc_soldier' }
    ],
    WAVES: [
      { waveNo:1, delay:2000, enemies:[{ type:'slime', count:5, interval:1000 }] }
    ],
    INITIAL_GOLD: 1000,
    INITIAL_LIVES:20
  };

  // 2) 道(grid)を生成
  function generatePathGrid(){
    const { MAP_ROWS:rows, MAP_COLS:cols } = CONFIG;
    const g = Array.from({length:rows}, ()=>Array(cols).fill(0));
    const dv=(c,rs,re)=>{ const s=rs<=re?1:-1; for(let r=rs; r!==re+s; r+=s) g[r][c]=1; };
    const dh=(r,cs,ce)=>{ const s=cs<=ce?1:-1; for(let c=cs; c!==ce+s; c+=s) g[r][c]=1; };
    dv(24,0,9);  dh(9,24,35);
    dv(35,9,19); dh(19,35,20);
    dv(20,19,29);dh(29,20,30);
    dv(30,29,39);dh(39,30,25);
    dv(24,39,49);
    return g;
  }
  const grid = generatePathGrid();

  // 3) BFSで道をたどりウェイポイント生成
  function findPath(grid,start,end){
    const rows=grid.length, cols=grid[0].length;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    const visited=Array.from({length:rows}, ()=>Array(cols).fill(false));
    const parent={};
    const q=[start];
    visited[start.r][start.c]=true;
    while(q.length){
      const cur=q.shift();
      if(cur.r===end.r && cur.c===end.c) break;
      for(const [dr,dc] of dirs){
        const nr=cur.r+dr, nc=cur.c+dc;
        if(nr>=0&&nr<rows&&nc>=0&&nc<cols && !visited[nr][nc] && grid[nr][nc]===1){
          visited[nr][nc]=true;
          parent[`${nr},${nc}`]=cur;
          q.push({r:nr,c:nc});
        }
      }
    }
    let node = visited[end.r][end.c] ? end : null;
    const path=[];
    while(node){
      path.push({r:node.r, c:node.c});
      const key = `${node.r},${node.c}`;
      node = parent[key];
    }
    return path.reverse();
  }
  const waypoints = findPath(grid, {r:0,c:24}, {r:49,c:24});

  // 4) ステージデータ
  const STAGE = {
    map: {
      tiles:    grid,
      rows:     CONFIG.MAP_ROWS,
      cols:     CONFIG.MAP_COLS,
      tileSize: CONFIG.TILE_SIZE
    },
    path:      { waypoints },
    waves:     CONFIG.WAVES,
    initial:   { gold:CONFIG.INITIAL_GOLD, lives:CONFIG.INITIAL_LIVES }
  };

  // 5) アセットローダー (タイル＋敵のみ)
  const assetLoader = {
    images:{},
    loadImages(){
      const keys = [
        'tile_grass','tile_road',
        ...CONFIG.ENEMY_DEFINITIONS.map(e=>e.spriteKey)
      ];
      return Promise.all(keys.map(key=>{
        const category = key.startsWith('tile_') ? 'tiles' : 'enemies';
        const img = new Image();
        img.src = `${CONFIG.ASSETS_PATH}/${category}/${key}.png`;
        this.images[key] = img;
        return new Promise(res=>img.onload=res);
      }));
    }
  };

  // 6) レンダラー
  const renderer = {
    ctx:null, images:null,
    init(id, images){
      this.images = images;
      this.ctx = document.getElementById(id).getContext('2d');
    },
    clear(){
      this.ctx.clearRect(0,0,
        STAGE.map.cols * STAGE.map.tileSize,
        STAGE.map.rows * STAGE.map.tileSize
      );
    },
    drawTile(r,c){
      const key = STAGE.map.tiles[r][c]===1 ? 'tile_road' : 'tile_grass';
      this.ctx.drawImage(
        this.images[key],
        c*STAGE.map.tileSize,
        r*STAGE.map.tileSize,
        STAGE.map.tileSize,
        STAGE.map.tileSize
      );
    },
    drawEnemy(e){
      this.ctx.drawImage(
        this.images[e.spriteKey],
        e.x,
        e.y,
        STAGE.map.tileSize,
        STAGE.map.tileSize
      );
    }
  };

  // 7) ゲームモデル
  const playModel = {
    enemies:[],
    gold:  STAGE.initial.gold,
    lives: STAGE.initial.lives,
    waypoints,
    spawnEnemy(type){
      const def = CONFIG.ENEMY_DEFINITIONS.find(e=>e.id===type);
      const wp0 = this.waypoints[0];
      this.enemies.push({
        ...def,
        x:   wp0.c * STAGE.map.tileSize,
        y:   wp0.r * STAGE.map.tileSize,
        idx: 1
      });
    }
  };

  // 8) ビュー
  const playView = {
    render(){
      renderer.clear();
      // 地形
      for(let r=0;r<STAGE.map.rows;r++){
        for(let c=0;c<STAGE.map.cols;c++){
          renderer.drawTile(r,c);
        }
      }
      // 敵
      playModel.enemies.forEach(e=>renderer.drawEnemy(e));
      // HUD
      document.getElementById('hud').textContent =
        `Gold: ${playModel.gold}   Lives: ${playModel.lives}`;
    }
  };

  // 9) ゲーム開始
  assetLoader.loadImages().then(()=>{
    renderer.init('game-canvas', assetLoader.images);
    playView.render();

    // 第1波スポーン
    setTimeout(()=>{
      STAGE.waves[0].enemies.forEach(e=>{
        for(let i=0;i<e.count;i++){
          setTimeout(()=>playModel.spawnEnemy(e.type), i*e.interval);
        }
      });
    }, STAGE.waves[0].delay);

    // メインループ：移動＆ゴールチェック
    setInterval(()=>{
      for(let i=playModel.enemies.length-1;i>=0;i--){
        const e = playModel.enemies[i];
        const wp = playModel.waypoints[e.idx];
        if(!wp){
          // ゴール到達 → ライフ減少＆削除
          playModel.lives--;
          playModel.enemies.splice(i,1);
          continue;
        }
        const tx = wp.c * STAGE.map.tileSize;
        const ty = wp.r * STAGE.map.tileSize;
        const dx = tx - e.x, dy = ty - e.y;
        const dist = Math.hypot(dx,dy);
        if(dist < e.speed) {
          e.idx++;
        } else {
          e.x += dx/dist * e.speed;
          e.y += dy/dist * e.speed;
        }
      }
      playView.render();
    }, 1000/60);
  });
  </script>
</body>
</html>
